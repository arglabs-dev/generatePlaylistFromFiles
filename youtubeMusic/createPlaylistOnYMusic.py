import argparse
import json
import logging
import os
import datetime
from typing import List, Dict, Optional
from ytmusicapi import YTMusic, OAuthCredentials

# Import configuration from separate file
import secrets_config

# --- CONSTANTS ---
LOG_FILENAME = f"migration_log_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
REPORT_FILENAME = f"migration_report_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.md"

class MigrationStats:
    def __init__(self):
        self.total_processed = 0
        self.found_in_ytm = 0
        self.uploaded = 0
        self.missing = 0
        self.added_to_playlist = 0

class MusicMigrator:
    def __init__(self, json_path: str, playlist_name: str, music_dir: Optional[str] = None):
        self.json_path = json_path
        self.playlist_name = playlist_name
        self.music_dir = music_dir
        self.stats = MigrationStats()
        self.report_rows: List[Dict[str, str]] = []
        
        # Initialize API using the file defined in secrets_config
        try:
            if not os.path.exists(secrets_config.OAUTH_FILE):
                raise FileNotFoundError(f"Auth file '{secrets_config.OAUTH_FILE}' not found. Run 'ytmusicapi oauth' first.")
            
            # self.yt = YTMusic(
            #     secrets_config.OAUTH_FILE,
            #     oauth_credentials=OAuthCredentials(
            #         client_id=secrets_config.CLIENT_ID,
            #         client_secret=secrets_config.CLIENT_SECRET
            #     )
            # )
            self.yt = YTMusic(secrets_config.BROWSER_FILE)
            logging.info("Authenticated successfully with YouTube Music.")
        except Exception as e:
            logging.critical(f"Authentication failed: {e}")
            raise

    def get_or_create_playlist_bkp(self) -> str:
        logging.info(f"Looking for playlist: '{self.playlist_name}'...")
        playlists = self.yt.get_library_playlists()
        for pl in playlists:
            if pl['title'] == self.playlist_name:
                logging.info(f"Playlist found. ID: {pl['playlistId']}")
                return pl['playlistId']
        
        logging.info("Playlist not found. Creating new one...")
        playlist_id = self.yt.create_playlist(self.playlist_name, "Auto-generated by MusicMigrator")
        return playlist_id
    
    def get_or_create_playlist(self) -> str:
        logging.info(f"Looking for playlist: '{self.playlist_name}'...")
        
        playlists = []
        try:
            # Intentamos leer las playlists. Si falla (400), capturamos el error.
            # A veces agregar un limit explícito ayuda a la API a no confundirse.
            playlists = self.yt.get_library_playlists(limit=50)
        except Exception as e:
            logging.warning(f"⚠️ No se pudo leer la lista de playlists (Error API: {e}).")
            logging.info("Asumiendo que la playlist no existe y creando una nueva...")
            playlists = []

        for pl in playlists:
            if pl['title'] == self.playlist_name:
                logging.info(f"Playlist found. ID: {pl['playlistId']}")
                return pl['playlistId']
        
        logging.info("Playlist not found (or listing failed). Creating new one...")
        try:
            playlist_id = self.yt.create_playlist(self.playlist_name, "Auto-generated by MusicMigrator")
            logging.info(f"Playlist created. ID: {playlist_id}")
            return playlist_id
        except Exception as e:
            logging.critical(f"FATAL: No se pudo crear la playlist. Verifica que tu canal de YTM exista. Error: {e}")
            raise

    def search_song(self, artist: str, title: str, album: str) -> Optional[str]:
        # Strategy 1: Specific
        query = f"{artist} {title} {album}".strip()
        results = self.yt.search(query, filter='songs')
        if results: return results[0]['videoId']

        # Strategy 2: General
        query = f"{artist} {title}".strip()
        results = self.yt.search(query, filter='songs')
        if results: return results[0]['videoId']
            
        return None

    def upload_file(self, filename: str) -> bool:
        if not self.music_dir: return False
        full_path = os.path.join(self.music_dir, filename)
        
        if not os.path.exists(full_path):
            logging.error(f"File not found locally: {full_path}")
            return False

        try:
            logging.info(f"Uploading file: {filename}...")
            self.yt.upload_song(full_path)
            return True
        except Exception as e:
            logging.error(f"Failed to upload {filename}: {e}")
            return False

    def process(self):
        start_time = datetime.datetime.now()
        logging.info(f"Starting migration at {start_time}")
        
        try:
            with open(self.json_path, 'r', encoding='utf-8') as f:
                songs = json.load(f)
        except Exception as e:
            logging.critical(f"Could not load JSON file: {e}")
            return

        playlist_id = self.get_or_create_playlist()
        ids_to_add = []

        for song in songs:
            self.stats.total_processed += 1
            title = song.get('Title', 'Unknown')
            artist = song.get('Artist', 'Unknown')
            album = song.get('Album', '')
            year = str(song.get('Year', ''))
            filename = song.get('SourceFile', '')

            logging.info(f"Processing: {artist} - {title}")
            
            video_id = self.search_song(artist, title, album)
            status = "Unknown"

            if video_id:
                status = "Found in YTM"
                self.stats.found_in_ytm += 1
                ids_to_add.append(video_id)
            else:
                if self.music_dir and filename:
                    if self.upload_file(filename):
                        status = "Uploaded (Processing)"
                        self.stats.uploaded += 1
                    else:
                        status = "Missing Local File"
                        self.stats.missing += 1
                else:
                    status = "Not Found"
                    self.stats.missing += 1

            self.report_rows.append({"Title": title, "Artist": artist, "Year": year, "Status": status})

            if len(ids_to_add) >= 20:
                self.yt.add_playlist_items(playlist_id, ids_to_add)
                self.stats.added_to_playlist += len(ids_to_add)
                ids_to_add = []

        if ids_to_add:
            self.yt.add_playlist_items(playlist_id, ids_to_add)
            self.stats.added_to_playlist += len(ids_to_add)

        end_time = datetime.datetime.now()
        duration = end_time - start_time
        self.generate_markdown_report(start_time, duration)
        logging.info(f"Migration finished in {duration}.")

    def generate_markdown_report(self, start, duration):
        with open(REPORT_FILENAME, 'w', encoding='utf-8') as f:
            f.write(f"# Migration Report\n\n")
            f.write(f"**Playlist:** {self.playlist_name} | **Date:** {start.strftime('%Y-%m-%d')} | **Duration:** {duration}\n\n")
            f.write("## Statistics\n")
            f.write(f"- Total: {self.stats.total_processed}\n- Found: {self.stats.found_in_ytm}\n- Uploaded: {self.stats.uploaded}\n- Missing: {self.stats.missing}\n\n")
            f.write("## Details\n| Title | Artist | Year | Status |\n|---|---|---|---|\n")
            for row in self.report_rows:
                f.write(f"| {row['Title'].replace('|','-')} | {row['Artist'].replace('|','-')} | {row['Year']} | {row['Status']} |\n")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Migrate local music to YouTube Music.")
    
    # Arguments use defaults from secrets_config.py
    parser.add_argument('--json', required=True, help="Path to JSON metadata file.")
    parser.add_argument('--playlist', default=secrets_config.DEFAULT_PLAYLIST_NAME, help="Target Playlist Name.")
    parser.add_argument('--music-dir', default=secrets_config.DEFAULT_MUSIC_DIR, help="Folder containing audio files.")
    
    args = parser.parse_args()

    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s [%(levelname)s] %(message)s',
        handlers=[logging.FileHandler(LOG_FILENAME, encoding='utf-8'), logging.StreamHandler()]
    )

    migrator = MusicMigrator(args.json, args.playlist, args.music_dir)
    migrator.process()